<# 
Fill-Missing-ValuesIt.ps1
Goal:
- DO NOT modify your existing values-it/strings.xml and values-it/arrays.xml.
- Generate two NEW files:
    app/src/main/res/values-it/strings_auto.xml
    app/src/main/res/values-it/arrays_auto.xml
  containing only the resources that exist in base values/ but are missing in values-it/.
This avoids "duplicate resource" errors.

Works with Windows PowerShell 5.1+ and PowerShell 7+.
#>

[CmdletBinding()]
param(
  [Parameter(Mandatory=$true)]
  [string]$Root,

  [string]$Locale = "it",

  [switch]$DryRun
)

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

$BaseDir   = Join-Path $Root "app\src\main\res\values"
$TargetDir = Join-Path $Root ("app\src\main\res\values-" + $Locale)

$StringsOut = Join-Path $TargetDir "strings_auto.xml"
$ArraysOut  = Join-Path $TargetDir "arrays_auto.xml"

Write-Host ""
Write-Host "Root   : $Root"
Write-Host "Base   : $BaseDir"
Write-Host "Target : $TargetDir"
Write-Host ""

if (!(Test-Path $BaseDir))   { throw "Base folder not found: $BaseDir" }
if (!(Test-Path $TargetDir)) { throw "Target folder not found: $TargetDir (create values-$Locale first)" }

# --- Helpers ---------------------------------------------------------------

function Get-XmlDoc([string]$filePath) {
  try {
    $raw = Get-Content -Path $filePath -Raw -Encoding UTF8
    return [xml]$raw
  } catch {
    Write-Warning ("Skipping (invalid XML?): " + $filePath)
    return $null
  }
}

# Return resources elements that we want to copy for a locale folder.
function Get-TranslatableResourceElements([xml]$doc) {
  if ($null -eq $doc) { return @() }
  if ($null -eq $doc.resources) { return @() }

  $wantedTypes = @(
    "string",
    "plurals",
    "string-array",
    "integer-array",
    "array"
  )

  $elements = @()
  foreach ($n in $doc.resources.ChildNodes) {
    if ($n.NodeType -ne [System.Xml.XmlNodeType]::Element) { continue }
    if ($wantedTypes -notcontains $n.Name) { continue }

    $nameAttr = $n.Attributes["name"]
    if ($null -eq $nameAttr) { continue }
    $name = $nameAttr.Value
    if ([string]::IsNullOrWhiteSpace($name)) { continue }

    $elements += $n
  }
  return $elements
}

function Make-Key([string]$type, [string]$name) {
  # IMPORTANT: don't do "$type:$name" (PowerShell thinks $type: is a drive prefix).
  return "$($type)|$name"
}

function Write-XmlUtf8NoBom([System.Xml.XmlDocument]$doc, [string]$outPath) {
  $settings = New-Object System.Xml.XmlWriterSettings
  $settings.Indent = $true
  $settings.IndentChars = "  "
  $settings.NewLineChars = "`n"
  $settings.NewLineHandling = "Replace"
  $settings.OmitXmlDeclaration = $false
  $settings.Encoding = [System.Text.UTF8Encoding]::new($false) # UTF-8 without BOM

  $writer = [System.Xml.XmlWriter]::Create($outPath, $settings)
  try {
    $doc.Save($writer)
  } finally {
    $writer.Close()
  }
}

function New-ResourcesDoc() {
  $doc = New-Object System.Xml.XmlDocument
  $decl = $doc.CreateXmlDeclaration("1.0", "utf-8", $null)
  $null = $doc.AppendChild($decl)

  $root = $doc.CreateElement("resources")
  $null = $doc.AppendChild($root)

  $comment = $doc.CreateComment(" AUTO-GENERATED by Fill-Missing-ValuesIt.ps1. Do not edit. ")
  $null = $root.AppendChild($comment)

  return $doc
}

# --- 1) Load base resources (values/) -------------------------------------

$baseMap = @{}   # key -> XmlElement
$baseSrc = @{}   # key -> filePath (for debug)

$baseFiles = Get-ChildItem -Path $BaseDir -Filter *.xml -File
foreach ($f in $baseFiles) {
  $doc = Get-XmlDoc $f.FullName
  foreach ($el in (Get-TranslatableResourceElements $doc)) {
    $type = $el.Name
    $name = $el.GetAttribute("name")
    $key  = Make-Key $type $name

    if (-not $baseMap.ContainsKey($key)) {
      $baseMap[$key] = $el
      $baseSrc[$key] = $f.Name
    }
  }
}

# --- 2) Load existing target resources (values-it/) ------------------------

$targetMap = @{} # key -> true
$ignoreGenerated = @("strings_auto.xml", "arrays_auto.xml")

$targetFiles = Get-ChildItem -Path $TargetDir -Filter *.xml -File | Where-Object { $ignoreGenerated -notcontains $_.Name }
foreach ($f in $targetFiles) {
  $doc = Get-XmlDoc $f.FullName
  foreach ($el in (Get-TranslatableResourceElements $doc)) {
    $type = $el.Name
    $name = $el.GetAttribute("name")
    $key  = Make-Key $type $name
    $targetMap[$key] = $true
  }
}

# --- 3) Compute missing ----------------------------------------------------

$missing = @()
foreach ($key in $baseMap.Keys) {
  if (-not $targetMap.ContainsKey($key)) {
    $missing += $key
  }
}

Write-Host ("Base items   : " + $baseMap.Count)
Write-Host ("IT items     : " + $targetMap.Count)
Write-Host ("Missing      : " + $missing.Count)
Write-Host ""

if ($missing.Count -eq 0) {
  Write-Host "Nothing missing. (You can keep your values-it folder as-is; Android will fallback to base values/.)"
  exit 0
}

# --- 4) Build output docs WITHOUT touching existing files ------------------

$docStrings = New-ResourcesDoc
$docArrays  = New-ResourcesDoc

$rootStrings = $docStrings.DocumentElement
$rootArrays  = $docArrays.DocumentElement

$addedStrings = 0
$addedArrays  = 0

foreach ($key in ($missing | Sort-Object)) {
  $srcEl = $baseMap[$key]
  $type  = $srcEl.Name

  if ($type -eq "string" -or $type -eq "plurals") {
    $imported = $docStrings.ImportNode($srcEl, $true)
    $null = $rootStrings.AppendChild($imported)
    $addedStrings++
  } else {
    $imported = $docArrays.ImportNode($srcEl, $true)
    $null = $rootArrays.AppendChild($imported)
    $addedArrays++
  }
}

Write-Host ("Will write strings_auto.xml entries : " + $addedStrings)
Write-Host ("Will write arrays_auto.xml entries  : " + $addedArrays)
Write-Host ""

if ($DryRun) {
  Write-Host "DryRun enabled: no file written."
  Write-Host "Example missing keys (first 25):"
  ($missing | Sort-Object | Select-Object -First 25) | ForEach-Object { Write-Host (" - " + $_) }
  exit 0
}

# Ensure target dir exists (it does, but keep safe)
New-Item -ItemType Directory -Path $TargetDir -Force | Out-Null

Write-XmlUtf8NoBom $docStrings $StringsOut
Write-XmlUtf8NoBom $docArrays  $ArraysOut

Write-Host "OK: wrote $StringsOut"
Write-Host "OK: wrote $ArraysOut"
Write-Host ""
Write-Host "Next: run -> .\gradlew :app:mergeDebugResources"
